{"version":3,"file":"index.js","sources":["../node_modules/hybrids/src/utils.js","../src/utils/index.js","../src/index.js"],"sourcesContent":["const camelToDashMap = new Map();\nexport function camelToDash(str) {\n  let result = camelToDashMap.get(str);\n  if (result === undefined) {\n    result = str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n    camelToDashMap.set(str, result);\n  }\n  return result;\n}\n\nexport function pascalToDash(str) {\n  return camelToDash(str.replace(/((?!([A-Z]{2}|^))[A-Z])/g, '-$1'));\n}\n\nexport function dispatch(host, eventType, options = {}) {\n  return host.dispatchEvent(new CustomEvent(eventType, { bubbles: false, ...options }));\n}\n\nexport function shadyCSS(fn, fallback) {\n  const shady = window.ShadyCSS;\n\n  /* istanbul ignore next */\n  if (shady && !shady.nativeShadow) {\n    return fn(shady);\n  }\n\n  return fallback;\n}\n\nexport function stringifyElement(element) {\n  const tagName = String(element.tagName).toLowerCase();\n  return `<${tagName}>`;\n}\n\nexport const IS_IE = 'ActiveXObject' in window;\nexport const deferred = Promise.resolve();\n","export function getType(value) {\n  switch (typeof value) {\n    case 'undefined': return undefined;\n    case 'number': return Number;\n    case 'boolean': return Boolean;\n    case 'object':\n      if (value === null) return null;\n      if (Array.isArray(value)) return Array;\n      return Object;\n    case 'function': return Function;\n    case 'string':\n    default: return String;\n  }\n}\n\nexport function coerceToType(value, type) {\n  switch (type) {\n    case String:\n    case Number:\n      return type(value);\n    case Boolean:\n      if (value === 'false' || (!value && value !== '')) return false;\n      return true;\n    case Array:\n      if (Array.isArray(value)) return value;\n      if (typeof value === 'string') {\n        return /^\\[.*\\]$/.test(value) ? JSON.parse(value) : [];\n      }\n      if (value) return type(value);\n      return [];\n    case Object:\n      return JSON.parse(value);\n    case Function:\n      return undefined;\n    default: return undefined;\n  }\n}\n\nexport function setAttr(host, attrName, type, val, oldValue) {\n  if (val !== oldValue) {\n    switch (type) {\n      case null:\n      case undefined:\n        break;\n      case Boolean:\n        if (val) {\n          host.setAttribute(attrName, '');\n        } else {\n          host.removeAttribute(attrName);\n        }\n        break;\n      case Array:\n        if (val === undefined || val === null || val.length === 0) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, JSON.stringify(val));\n        }\n        break;\n      case Object:\n        if (val === undefined || val === null || Object.keys(val).length === 0) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, JSON.stringify(val));\n        }\n        break;\n      case Function:\n        break;\n      case String:\n        if (val === '' || val === undefined || val === null) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, val);\n        }\n        break;\n      case Number:\n      default:\n        if (val === undefined || val === null) {\n          host.removeAttribute(attrName);\n        } else {\n          host.setAttribute(attrName, val);\n        }\n        break;\n    }\n  }  \n}\n","import { property } from 'hybrids';\nimport { camelToDash } from 'hybrids/src/utils';\nimport { getType, coerceToType, setAttr } from './utils';\n\n// Keep track of any instances of any components that use reflected attributes.\nconst hosts = new WeakMap();\n\n// Keep track of all reflected attributes, by component tag name.\nconst reflectedAttributes = new Map();\n\nexport default function reflect(value, methods = {}) {\n  let type;\n  let attrName;\n  let observer;\n  const properties = {\n    ...property(value, function connect(host, key) {\n      type = getType(value);\n      attrName = camelToDash(key);\n      const tagName = host.tagName;\n\n      // Assign all reflected attributes to a map whose lookup is the tagName.\n      const attrMap = reflectedAttributes.get(tagName) || new Map();\n      reflectedAttributes.set(tagName, attrMap.set(attrName, {key, type}));\n\n      // Set coerced value for key, as derived from attribute.\n      const attrValue = host.getAttribute(attrName);\n      if (attrValue !== null) {\n        value = coerceToType(attrValue, type);\n        host[key] = value;\n      }\n\n      // Only assign a single mutation observer to watch any single host, no matter how many reflected keys it has.\n      const hasObserver = hosts.get(host);\n      if (!hasObserver) {\n        observer = new MutationObserver((mutations) => {\n          const watchedAttrs = reflectedAttributes.get(tagName);\n          mutations.forEach(({ attributeName, target }) => {\n            const watchedAttr = watchedAttrs.get(attributeName);\n            if (watchedAttr) {\n              const {key, type} = watchedAttr;\n              const attrValue = target.getAttribute(attributeName);\n              const value = coerceToType(attrValue, type);\n              if (value !== host[key]) {\n                target[key] = value;\n              }\n            }\n          });\n        });\n        hosts.set(host, true);\n        observer.observe(host, { attributes: true });\n      }\n\n      // Call any individually defined `connect` method the property may have.\n      let disconnectFn;\n      if (methods.connect) {\n        disconnectFn = methods.connect(host, key);\n      }\n\n      // Once a host disconnects, stop watching it and remove it from WeakMap.\n      // Only run code once no matter how many reflected keys it has.\n      return () => {\n        disconnectFn && disconnectFn();\n        if (observer) {\n          observer.disconnect();\n          hosts.delete(host);  \n        }\n      }\n    }),\n  }\n  const _get = properties.get;\n  properties.get = (host, val = value) => {\n    let newVal;\n    if (methods.get) newVal = methods.get(host, val);\n    return _get(host, newVal !== undefined ? newVal : val);\n  };\n  const _set = properties.set;\n  properties.set = (host, val, oldValue) => {\n    let newVal;\n    if (methods.set) newVal = methods.set(host, val, oldValue);\n    _set(host, newVal !== undefined ? newVal : val, oldValue)\n  };\n  properties.observe = (host, value, oldValue) => {\n    let newVal;\n    if (methods.observe) newVal = methods.observe(host, value, oldValue);\n\n    // If a reflected property changes, reflect that change to the attribute.\n    setAttr(host, attrName, type, newVal !== undefined ? newVal : value, oldValue)\n  };\n  return properties;\n}\n\nexport {\n  getType,\n  coerceToType,\n}\n"],"names":["camelToDashMap","Map","getType","value","Number","Boolean","Array","isArray","Object","Function","String","coerceToType","type","test","JSON","parse","hosts","WeakMap","reflectedAttributes","methods","attrName","observer","properties","property","host","key","str","result","get","undefined","replace","toLowerCase","set","camelToDash","tagName","attrMap","attrValue","getAttribute","disconnectFn","MutationObserver","mutations","watchedAttrs","forEach","attributeName","target","watchedAttr","observe","attributes","connect","disconnect","delete","_get","val","newVal","_set","oldValue","setAttribute","removeAttribute","length","stringify","keys","setAttr"],"mappings":"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"}